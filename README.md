cd D:\DWH_VNK_IMPORT\00.General\DEVELOPMENT
or
cd D:\DB\DWH_VC_AVT\DEVELOPMENT\GIT\SSAS

git init                  (инициализируем каталог Гит для его работы и отслеживания изменений.
git add *                 (добавить все, включая папаки и подпапки)
                           При этом в той папке где мы находимся создается папка = ".git" с нужной структурой)
git add *.txt             (добавляем в папку ".git" (это наш локальный репозиторий) файлы по маске *.txt
                           при этом можно добавлять и отдельные файлы и целые папки с подпапками внутри)
git commit -m 'Ver.0'     (комитим вышесделанную работу помечая комит сообщением\меткой\описанием = "Ver.0"
                           ключ -m значит "message". Но чтобы это работало, перед тем как комить файл
                           нужно запускать каждый раз комманду git add ИмяФайла\Директории)
git commit -a -m 'Add new benchmarks' (в данном случае, указав ключ "-a" нет необходимости предварительно
                                       запускать команду git add)
git remote add avt https://github.com/pdobrokhotov/DWH_VC_AVT (добавление удаленного репозитория под локальным именем pb)
ПРИМЕЧАНИЕ: Вместо добавления ссылки на удаленную директорию мы могли бы вполнить команду 
            git clone https://github.com/schacon/ticgit
git branch -r (see remote branches = avt/master)
git fetch avt (refresh remote (upsteram) branch
git checkout avt/master 
-------------------------- связывание удаленных и локальных веток-----------------
git push --set-upstream avt master
         
--------------------- NOTE: REDOING THE COMMIT IF FORGOT SMTH ----------------------------
As an example, if you commit and then realize you forgot to stage the changes in a file you wanted
to add to this commit, you can do something like this:
git commit -m 'Initial commit'
git add forgotten_file
git commit --amend
You end up with a single commit — the second commit replaces the results of the first.
It’s important to understand that when you’re amending your last commit, you’re
not so much fixing it as replacing it entirely with a new, improved commit that
pushes the old commit out of the way and puts the new commit in its place.
Effectively, it’s as if the previous commit never happened, and it won’t show up in
your repository history.
============================= RENAMING TRACKED FILES ===========================================================
git rm ИмяФайла\Директории (отключает трекинг файла для Git. После этого Git уже не будет "видеть" этот файл
                           (команда также удаляет сам файл!!!)
                           The next time you commit, the file will be gone and no longer tracked. 
                           If you modified the file or had already added it to the staging area, you must force the removal
                           with the -f option. This is a safety feature to prevent accidental removal of data that 
                           hasn’t yet been recorded in a snapshot and that can’t be recovered from Git.
                           Another useful thing you may want to do is to keep the file in your working tree 
                           but remove it from your staging area. In other words, you may want to keep the file 
                           on your hard drive but not have Git track it anymore. This is particularly useful 
                           if you forgot to add something to your .gitignore file
$ git rm --cached ИмяФайла (убрать файл из области Stage. Вмеcто ключа --cached можно использовать синоним --staged)
git rm \*~   (This command removes all files whose names end with a ~. )
git rm log/\*.log (This command removes all files that have the .log extension in the log/ directory)
-------------Note------------
можно настроить Git так чтобы он игнорировал добавление файлов по маске
Для этого надо отредлактировать специальный файл = .gitignore. Например:
                   notepad .gitignore (see page 32)
GitHub maintains a fairly comprehensive list of good .gitignore file examples for
dozens of projects and languages at https://github.com/github/gitignore if you want
a starting point for your project.
-----------------------------
===================================== Переименование файла =========================
git mv README.md README   (Перименовали фал для отслеживания теперь вместо отслеживания файла README.md 
                           будем отслеживать README )
Команда выше равносильно выполнению команд ниже
mv README.md README
git rm README.md
git add README
===================== UNDOING CHANGEs AND RETURN TO ORIGNAL STATE OF FILE==========
This is dangeroes operation, no sometimes needed
git checkout -- <file>  (is a dangerous command that returns the last commited version of file)
                         Any local changes you made to that file are gone — Git just replaced that file with
                         the last staged or committed version. Don’t ever use this command unless you
                         absolutely know that you don’t want those unsaved local changes.
                         Remember, anything that is committed in Git can almost always be recovered. Even commits that
                         were on branches that were deleted or commits that were overwritten with 
                         an --amend commit can be recovered
git restore <file>          (It’s basically an alternative to git reset. 
git restore --staged <file> (unstage file that was added to Index by mistake)
git reset HEAD <file>       (unstage file that was added to Index by mistake)


===================================================================================
============================= как увидеть статус\состяние изменений файла==========
git status -a   (Общая информация по файлам в рабочей директории. -a значит all)
git diff        (Подробная информация по кадому изменению файла)    
If you want to see what you’ve staged that will go into your next commit, you can use 
git diff --staged  (This command compares your staged changes to your last commit)
==================================================================================================

--клонирование проекта (стр 27). Фактически это копирования дальнего репозитория в локальную рабочую папку
git clone https://github.com/libgit2/libgit2
Эта команда создаёт каталог libgit2, инициализирует в нём подкаталог .git, скачивает все
данные для этого репозитория и извлекает рабочую копию последней версии. Если вы
перейдёте в только что созданный каталог libgit2, то увидите в нём файлы проекта,
готовые для работы или использования. Для того, чтобы клонировать репозиторий в
каталог с именем, отличающимся от libgit2, необходимо указать желаемое имя, как
параметр командной строки.Эта команда делает всё то же самое, что и предыдущая, 
только результирующий каталог будет назван mylibgit.
$ git clone https://github.com/libgit2/libgit2 mylibgit
В резултате на локальном компьютере имеем папку D:\DWH_VNK_IMPORT\00.General\DEVELOPMENT\mylibgit
со всеми файлами скачеными с сайта ГитХаб


https://habr.com/ru/post/106912/
оздание ветви функциональности (feature branch)
При начале работы над новой функциональностью делается ответвление от ветви разработки (develop).
$ git checkout -b myfeature develop
Switched to a new branch "myfeature"

Добавление завершённой функциональности в develop
Завершённая функциональность (фича) вливается обратно в ветвь разработки (develop) и попадает в следующий релиз.

$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff myfeature

Флаг --no-ff вынуждает Git всегда создавать новый объект коммита при слиянии, даже если слияние может 
быть осуществлено алгоритмом fast-forward. Это позволяет не терять информацию о том, что ветка существовала, 
и группирует вместе все внесённые изменения.

git commit -m 'ИмяМоейМеткиИзменений'
git commit -m TestFileForGit.txt

--просмотр дальних репозиториев
$ git clone https://github.com/schacon/ticgit
$ cd ticgit
git remote -v    
---------- result-----------
origin https://github.com/schacon/ticgit (fetch)
origin https://github.com/schacon/ticgit (push)
----------------------------
Также есть еще один вариант просмотра. Эта команда выдаёт URL удалённого репозитория, 
а также информацию об отслеживаемых ветках
git remote show origin
--------- result -----------------------
* remote origin
Fetch URL: https://github.com/schacon/ticgit
Push URL: https://github.com/schacon/ticgit
HEAD branch: master
Remote branches:
master tracked
dev-branch tracked
Local branch configured for 'git pull':
master merges with remote master
Local ref configured for 'git push':
master pushes to master (up to date)
-----------------------------------------

--добавление дальнего репозитория----------------
git remote add pb https://github.com/paulboone/ticgit  (добавили репозиторий под именем = pb )
И если теперь опять просмотрим его данные коандой "git remote -v"  получим
pb https://github.com/paulboone/ticgit (fetch)
pb https://github.com/paulboone/ticgit (push)
Теперь вместо указания полного пути вы можете использовать pb.
Т.е. чтобы получить изменения выполним "загрузку репозитория" по имени
git fetch pb  (потом можно периименовать репозитори "pb" в "paul" командой  "git remote rename pb paul"
---------- result-----------
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
* [new branch] master -> pb/master
* [new branch] ticgit -> pb/ticgit
------------------------------------
Есть похожая команда = git pull, которая работает как git fetch но при этом делает 
еще и мердж вашей ветки с далней веткой
Выполнение git pull, как правило, извлекает (fetch) данные с сервера, с которого
вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над
которым вы в данный момент работаете
==========================ПРИМЕЧАНИЕ==================================
Начиная с версии 2.27, команда git pull выдаёт предупреждение, если
настройка pull.rebase не установлена. Git будет выводить это
предупреждение каждый раз пока настройка не будет установлена.
Если хотите использовать поведение Git по умолчанию (простое смещение
вперёд если возможно — иначе создание коммита слияния): 
git config --global pull.rebase "false"
Если хотите использовать перебазирование при получении изменений: 
git config --global pull.rebase "true"
========== Отправка изменений в удаленный репозиторий (Push) ============ 
git push origin master  (отправки ваших коммитов)
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас
есть права на запись, и если никто другой с тех пор не выполнял команду push
В противном случае Вам придётся сначала получить изменения и объединить их с вашими 
и только после этого вам будет позволено выполнить push.

=============== Удаление и переименование дальних репозиториев ================
git remote rename pb paul (переименовали репоизиторий pb --> paul
git remote remove paul    (удалили репозиторий paul    )


===================== ТЭГИ ===========================
Тэги используются для пометки важных моментов в разработке. Например указать что это версия = 1.0
Теги бывают легковесными (простыми, т.е. указывается метка на комит) и аннотированными
)т.е. указщывается подробная информация, имя, имейлб дату создания итд)
--просмотр тегов
git tag (параметры -l и --list опциональны)
--поиск тега по шаблону
$ git tag -l "v1.8.5*"
--создание и прсмотр данных аннотированого тега  вместе с коммитом командой git show
git tag -a v1.4 -m "my version 1.4" (Опция -m задаёт сообщение, которое будет храниться вместе с тегом.)
git show v1.4

Легковесный тег — это ещё один способ пометить коммит. По сути, это контрольная сумма
коммита, сохранённая в файл — больше никакой информации не хранится. Для создания
легковесного тега не передавайте опций -a, -s и -m, укажите только название:
git tag 1.1

Тег коммиту можно присвоить вдогонку. Для этого сначала смотрим лог коммитов
git log --pretty=oneline (или = git log --oneline --decorate)
а потмо берем весь или только несколько символов строки контрольной суммы ( = 9fceb02)
git tag -a v1.2 9fceb02
=========================== Удаление тегов ===============
Локальные Теги можно и удалять: 
git tag -d 1.0.1   
Дальние Теги тоже, но для этого надо пушить : 
git push origin :refs/tags/1.0.1 To /git@github.com:schacon/simplegit.git
Другой вариант, более простой = git push origin --delete <tagname>

============================Обмен тегами========================
По умолчанию, команда git push не отправляет теги на удалённые сервера. После создания
теги нужно отправлять явно на удалённый сервер. Процесс аналогичен отправке
веток — достаточно выполнить команду git push origin <tagname>.
git push origin v1.5
Если у вас много тегов, и вам хотелось бы отправить все за один раз, то можно
использовать опцию --tags для команды git push.
git push origin --tags
ПРИМЕЧАНЕИЕ git push отправляет оба типа тегов (простоые и аннотирование)
Но если надо только аннотированне - git push <remote> --follow-tags
Только простые пока нельзя ((
=======================создание + просмотр даннеых новой ветки ===========================================
git branch testing      (создали новую ветку = testing но еще не переключилисьб на нее)
можно создавать ветку и тутже переключаться используя 2 синтаксиса комманд ниже
   git checkout -b testing  (создали новую ветку = testing и тут же переключилисьб на нее) 
   git switch -c testing   (создали новую ветку = testing и тут же переключилисьб на нее Начиная с Git версии 2.23)
   git switch -            (Вернуться к предыдущей извлечённой ветке)
--просмотр лога
git log --oneline --decorate  (видим что последний комиит сыылается но новую ветку testing и текущую master)
git checkout testing (переключаемся на ветку testing )
git switch testing  (переключаемся на ветку testing, поддержка этой команды ттлолько с Git ver2.23 )
================== просмотр лога ====================
git log testing  (прсмотр лога ветки testing . Если не указать ветку будет выбрана текущая )
git log --all    (просмотр лога всех веток)
Для отображения истории коммитов, текущего положения указателей веток и истории ветвления выполните команду 
git log --oneline --decorate --graph --all
---------------------
git checkout master  (переключились на master и сделали изменнения)
git commit -a -m 'made_changes_in_branch_master' (прокоммитили в master)

git checkout  testing (переключились на testing и сделали изменения)
git commit -a -m 'made_changes_in_branch_testing' (прокоммитили в testing )
---------------- ОЧЕНЬ ВАЖНО--------------------
Используя ключ --track мы можем создать локальную ветку которая паривязана к удаленно
так что потом выполяняя команду git pull мы можем загрузить и прокомить изменения
нашей локальной ветки на основе изменений сделаных в дальней ветке
При этом, разумеется у нас должна быть УЖЕ создана одноименная локальная ветка которую мы меняем локально
git checkout --track origin/serverfix
-----------------------------------------------------------------
Иногда у нас уже еть локальная ветка, тогда чтобы сдеать ее "tracking"-веткой вдогонку 
используем ключ -u или ключ --set-upstream-to (что одно и то же)
git branch -u origin/serverfix
В случе сомнений, что у нас трекится запускаем команду: git branch -vv 
котрая скажет какая ветка текущая, какой последний тэг, какие другие ветки есть итд. 

======================== работа с веткам =======================
git branch             (выводит список всех веток , текущая ветка помечена звездочкой
git branch -v          (показывает последний коммит на каждой из веток)
git branch --merged    (показывает те ветки, которые мы  уже слили с текущей)
                       Т.е. ветки из этого списка, перед которыми нет символа *, 
                       можно смело удалять командой git branch -d;
git branch --no-merged (показывает те ветки, которые мы  НЕ слили с текущей)
git branch -d  testing (удаляет ветку testing. причем нельзя удалять неслиту ветку.
                       Но если использовать ключ -D удаление будет сделано принудительно)
ПРИЕЧАНИЕ git branch для --merged или --no-merged показывает инфу для текущей ветки
Если вы сейчас не втой ветке, например переключились на ветку testing
вы из этой не той ветки все равно можете глянуть информацию для ветки master казав доп. параметр
git checkout testing (перешли в другю ветку)
$ git branch --no-merged master (из ветки testing все равно получаем инфу для ветки master)

================================================================= 


Основы ветвления и слияния
Давайте рассмотрим простой пример рабочего процесса, который может быть полезен в
вашем проекте. Ваша работа построена так:
1. Вы работаете над сайтом.
2. Вы создаете ветку для новой статьи, которую вы пишете.
3. Вы работаете в этой ветке.
В этот момент вы получаете сообщение, что обнаружена критическая ошибка, требующая
скорейшего исправления. Ваши действия:
1. Переключиться на основную ветку.
2. Создать ветку для добавления исправления.
3. После тестирования слить ветку содержащую исправление с основной веткой.
4. Переключиться назад в ту ветку, где вы пишете статью и продолжить работать.


--добавление дальнего репозитория----------------
git remote add pb https://github.com/paulboone/ticgit  (добавили репозиторий под именем = pb )
И если теперь опять просмотрим его данные коандой "git remote -v"  получим
pb https://github.com/paulboone/ticgit (fetch)
pb https://github.com/paulboone/ticgit (push)
Теперь вместо указания полного пути вы можете использовать pb.
Т.е. чтобы получить изменения выполним "загрузку репозитория" по имени
git fetch pb  (потом можно периименовать репозитори "pb" в "paul" командой  "git remote rename pb paul"
---------- result-----------
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
* [new branch] master -> pb/master
* [new branch] ticgit -> pb/ticgit
------------------------------------
Есть похожая команда = git pull, которая работает как git fetch но при этом делает 
еще и мердж вашей ветки с далней веткой
Выполнение git pull, как правило, извлекает (fetch) данные с сервера, с которого
вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над
которым вы в данный момент работаете
==========================ПРИМЕЧАНИЕ==================================
Начиная с версии 2.27, команда git pull выдаёт предупреждение, если
настройка pull.rebase не установлена. Git будет выводить это
предупреждение каждый раз пока настройка не будет установлена.
Если хотите использовать поведение Git по умолчанию (простое смещение
вперёд если возможно — иначе создание коммита слияния): 
git config --global pull.rebase "false"
Если хотите использовать перебазирование при получении изменений: 
git config --global pull.rebase "true"
========== Отправка изменений в удаленный репозиторий (Push) ============ 
git push origin master  (отправки ваших коммитов)
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас
есть права на запись, и если никто другой с тех пор не выполнял команду push
В противном случае Вам придётся сначала получить изменения и объединить их с вашими 
и только после этого вам будет позволено выполнить push.

=============== Удаление и переименование дальних репозиториев ================
git remote rename pb paul (переименовали репоизиторий pb --> paul
git remote remove paul    (удалили репозиторий paul    )

===============================================================================
===================== ТЭГИ ====================================================
===============================================================================
Like most VCSs, Git has the ability to tag specific points in a repository’s history as being important.
Typically, people use this functionality to mark release points (v1.0, v2.0 and so on). In this section,
you’ll learn how to list existing tags, how to create and delete tags, and what the different types of
tags are. Git supports two types of tags: lightweight and annotated.
1) Lightweight tag is very much like a branch that doesn’t change — it’s just a pointer to a specific commit.
                   git tag v1.4 -lw             
2) Annotated tags, 
                   git tag -a v1.4 -m "my version 1.4"
however, are stored as full objects in the Git database. They’re checksummed;
contain the tagger name, email, and date; have a tagging message; and can be signed and verified
with GNU Privacy Guard (GPG). It’s generally recommended that you create annotated tags so you
can have all this information; but if you want a temporary tag or for some reason don’t want to
keep the other information, lightweight tags are available too.

----------------------------- ADD LATE TAGS (LOCALY)  --------------------------------------------
You can also tag commits after you’ve moved past them. First find out tag's commot code
git log --pretty=oneline ( for example it is = 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment')
Then, after finding beede commit number, use it's several first digits
                     git tag -a v1.2 15027  (add local tag)
                     $ git tag -d v1.4-lw
---------------------------- PUSHING TAGS (to REMOTE)  ----------------------------------------------
By default, the git push command doesn’t transfer tags to remote servers. You will have to explicitly
push tags to a shared server after you have created them. This process is just like sharing remote branches,
you can run git push origin <tagname>.
                    git push origin v1.5   (push a given tag only)
                    git push origin --tags (push ALL tags)
---------------------------- DELETE TAGS   ----------------------------------------------
                   git tag -d v1.4-lw                  (delete local tag)
                   git push origin --delete v1.4-lw    (delete remote tag) 
 -----------------------------------------------------------------------------------------------------
Тэги используются для пометки важных моментов в разработке. Например указать что это версия = 1.0
Теги бывают легковесными (простыми, т.е. указывается метка на комит) и аннотированными
)т.е. указщывается подробная информация, имя, имейлб дату создания итд)
--просмотр тегов
git tag (параметры -l и --list опциональны)
--поиск тега по шаблону
$ git tag -l "v1.8.5*"
--создание и прсмотр данных аннотированого тега  вместе с коммитом командой git show
git tag -a v1.4 -m "my version 1.4" (Опция -m задаёт сообщение, которое будет храниться вместе с тегом.)
git show v1.4
Легковесный тег — это ещё один способ пометить коммит. По сути, это контрольная сумма
коммита, сохранённая в файл — больше никакой информации не хранится. Для создания
легковесного тега не передавайте опций -a, -s и -m, укажите только название:
git tag 1.1

Тег коммиту можно присвоить вдогонку. Для этого сначала смотрим лог коммитов
git log --pretty=oneline (или = git log --oneline --decorate)
а потмо берем весь или только несколько символов строки контрольной суммы ( = 9fceb02)
git tag -a v1.2 9fceb02
=========================== Удаление тегов ===============
Локальные Теги можно и удалять: 
git tag -d 1.0.1   
Дальние Теги тоже, но для этого надо пушить : 
git push origin :refs/tags/1.0.1 To /git@github.com:schacon/simplegit.git
Другой вариант, более простой = git push origin --delete <tagname>

============================Обмен тегами========================
По умолчанию, команда git push не отправляет теги на удалённые сервера. После создания
теги нужно отправлять явно на удалённый сервер. Процесс аналогичен отправке
веток — достаточно выполнить команду git push origin <tagname>.
git push origin v1.5
Если у вас много тегов, и вам хотелось бы отправить все за один раз, то можно
использовать опцию --tags для команды git push.
git push origin --tags
ПРИМЕЧАНЕИЕ git push отправляет оба типа тегов (простоые и аннотирование)
Но если надо только аннотированне - git push <remote> --follow-tags
Только простые пока нельзя ((
=======================создание новой ветки =============================================================
           git branch testing  (создали новую ветку = testing но еще не переключилисьб на нее)
============создание локальной ветки настроеннуой на следение удаленной ветки ============================
           git branch -u origin/serverfix (Если уже есть локальная ветка и надо настроить 
                                           ее на слежение за удалённой веткой, которую только что получили, 
                                           или хотим изменить используемую upstream-ветку, то используем параметрами
                                           -u или --set-upstream-to для команды git branch)
=============== просмотр состояний остлеживаемых (upstream) вето с помощтю ключа -vv =====================
Если вы хотите посмотреть как у вас настроены ветки слежения, воспользуйтесь опцией -vv для команды git branch.
Это выведет список локальных веток и дополнительную информацию о том, какая из веток отслеживается, отстаёт, 
опережает или всё сразу относительно отслеживаемой.
           git fetch --all  (сначала рефрешимся с дальним сервером, иначе команда ниже даст результат прошлого рефреша)
           git branch -vv   (смотрим разницу между соответсвующими локальными и дальними ветками)
           2 команды выше можно запустить одной строкой =  git fetch --all; git branch -vv
ПРИМЕЧАНИЕ git fetch получает с сервера все изменения, которых у вас ещё нет, но не изменяет состояние докальной 
рабочей копии. Поэтому надо самостоятельно сделать слияние. Тем не менее, существует команда git pull,
которая в большинстве случаев является командой git fetch, за которой непосредственно следует команда git merge.
--------------------------ПРИМЕЧАНИЕ-----------------------------
Прежде чем смотреть инфу с удаленного сервера, прорефрешь локальный кэш
git fetch --all; git branch -vv

================== переключение на ветку и просмотр даннеых===============================
git checkout testing    (переключаемся на ветку testing если ее предварительно создали командой git branch testing )
git checkout -b testing (одновременно создаем новую ветку и перключаемся на нее)
git branxh -D testing   (удаляем ветку testing. Ключ "-D" должен быть именно в верхнем регистре)
================== просмотр лога ==========================================================
git log --oneline --decorate  (видим что последний комиит сыылается но новую ветку testing и текущую master)
git log testing  (прсмотр лога ветки testing . Если не указать ветку будет выбрана текущая )
git log --all    (просмотр лога всех веток)
Для отображения истории коммитов, текущего положения указателей веток и истории ветвления выполните команду 
git log --oneline --decorate --graph --all
---------------------
git checkout master  (переключились на master и сделали изменнения)
git commit -a -m 'made_changes_in_branch_master' (прокоммитили в master)

git checkout  testing (переключились на testing и сделали изменнения)
git commit -a -m 'made_changes_in_branch_testing' (прокоммитили в testing )
--------------
Если кто-то в дальнем репозитории (на который у нас есть именновання ссылка) создал новую ветку=serverfix
то мы можем синхронизировать данные локального репозитория с дальним репозиторием командой fetch
  git fetch origin (origin - это именнованная ссылка например на сайт\сервер, которая у нас локально 
зарегестрирована когда например мы делали команду clone или просто создавали именнованную ссылку)
Однако при этом данные для новой дальней ветка у нас не появятся еще. 
Появится только ссылка\ярляк на эту ветку (origin/serverfix)
Чтобы данные ветки реально закачались локально надо:
- если локальной ветки еще нет и с ней надо поработать то сначала надо ее создать
  и тут же на нее перключиться. Автоматическое  создание делается при помощи ключа = -b  
  а переключение - командой checkout 
             git checkout -b serverfix origin/serverfix
                   или
             git checkout -b sf origin/serverfix (если локальную ветку надо сделать под другим именем)
  Теперь ваша локальная ветка serverfix или sf будет автоматически получать изменения из origin/serverfix.

- когда локальная ветка создана можно сделать мердж дальней и локальной ветки 
  (origin/serverfix и serverfix соответсвенно)
              git merge origin/serverfix
  Это создаст локальную ветку, в которой можно работать и которая будет начинаться там же, где и origin/serverfix
---------------------------------ПРИМЕЧАНИЕ----------------------------------------------
Получение локальной ветки из удалённой ветки автоматически создаёт то, что называется
«веткой слежения» (а ветка, за которой следит локальная называется «upstream branch»).
Ветки слежения — это локальные ветки, которые напрямую связаны с удалённой веткой.
Если, находясь на ветке слежения, выполнить git pull, то Git уже будет знать с какого
сервера получать данные и какую ветку использовать для слияния.
При клонировании репозитория, как правило, автоматически создаётся ветка master,
которая следит за origin/master. Однако, при желании вы можете настроить отслеживание и
других веток — следить за ветками на других серверах или отключить слежение за веткой
master. Вы только что видели простейший пример, что сделать это можно с помощью
команды git checkout -b <branch> <remote>/<branch>. Это часто используемая команда,
поэтому Git предоставляет сокращённую форму записи в виде флага --track:
             git checkout --track origin/serverfix 
выполнив команду выше видим на экране
Branch serverfix set up to track remote branch serverfix from origin. Switched to a new branch 'serverfix'
Но все можно сделать еще ПРОЩЕ! Если нам надо извлечь ветку, которая не существует локально, но
существует только одна удалённая ветка с точно таким же именем, то Git автоматически создаст ветку слежения:
             git checkout serverfix

Видим на экране:
Branch serverfix set up to track remote branch serverfix from origin.Switched to a new branch 'serverfix'
-------------------------------------------------------------------------------------
============================= Переименование ветки =========================
есть ветка bad-branch-name надо ее перименовать в  corrected-branch-name
и отправить изменени на сайт ГитХаб
git branch --move bad-branch-name corrected-branch-name (переименовываем, но изменения локальны)
git push --set-upstream origin corrected-branch-name (отправлем на сайт, так чтобы все увидели изменения)
Теперь проверим, где мы сейчас находимся:
git branch --all
---------и видим на экране результат -----------------------
* corrected-branch-name
main
remotes/origin/bad-branch-name
remotes/origin/corrected-branch-name
remotes/origin/main
----------------------------------
видим что и старая и новые ветки есть на сайте. поэтому удаляем старую
git push origin --delete bad-branch-name
Еще пример. Часто переименовывают ветку master в main а потом удалют master
git branch --move master main (изменения пока локальны)
git push --set-upstream origin main  (отправляем на дальний сервер\сайт)
git push origin --delete master (удалем ветку master на дальнем сервере\сайте)
ПРИМЕЧАНИЕ! перед тем как удалять ветку на сайте (что опасно!) убедись что сделал шаги ниже
1) Все проекты, которые зависят от текущего, должны будут обновить свой код и/или конфигурацию.
2) Обновите конфигурацию всех запускаемых тестов.
3) Исправьте скрипты сборки и публикации артефактов.
4) Поправьте настройки репозитория на сервере: задайте новую ветку по умолчанию,
5) обновите правила слияния, а также прочие настройки, которые зависят от имени веток.
6) Обновите документацию, исправив ссылки, указывающие на старую ветку.
7) Слейте или отмените запросы на слияние изменений, нацеленные на старую ветку.
==================================== Удалённые ветки\ссылки========================================
Удалённые ссылки — это ссылки (указатели) в ваших удалённых репозиториях, включая
ветки, теги и так далее. Полный список удалённых ссылок можно получить с помощью
команды 
git ls-remote <remote> 
      или команды 
git remote show <remote> 
для получения удалённых веток и дополнительной информации. Тем не менее, более распространенным
способом является использование веток слежения. Имена веток слежения имеют вид <remote>/<branch>.
          origin/master (ветка = master на сервере\сайте = origin)
При этом будет и обычная ветка = master которая по сути изначально хранит тоже самое что и  origin/master
Если вы с коллегой работали над одной задачей и он
отправил на сервер ветку iss53, при том что у вас может быть своя локальная ветка iss53,
удалённая ветка будет представлена веткой слежения с именем 
          origin/iss53.
ПРИМЕЧАНИЕ Скажем, у вас в сети есть свой Git-сервер с адресом git.ourcompany.com. 
Если вы с него что-то клонируете, команда clone автоматически назовёт его origin, 
заберёт оттуда все данные, создаст указатель на то, на что там указывает ветка master, 
и назовёт его локально origin/master
origin» — это название по умолчанию для удалённого сервера.
Но оно может быть и другим, например = booyah/master если мы выполним команду клонирования ниже
git clone -o booyah
Для синхронизации ваших изменений с удаленным сервером выполните команду
git fetch origin
======================= работа с несколькими репозиториями ===================
предположим, что у вас есть ещё один внутренний Git-сервер, который используется для разработки 
только одной из ваших команд разработчиков. Этот сервер находится на git.team1.ourcompany.com. 
Вы можете добавить его в качестве новой удалённой ссылки для текущего проекта с помощью команды 
git remote add, как показано ниже. Назовите этот удалённый сервер teamone — это имя будет сокращением 
вместо полного URL.
git remote add teamone git://git.team1.ourcompany.com  (добавили репозиторий под именем = teamone)

================== отправка локальной (доработанной ветки) на дальний репозиторий =============
-- Синтаксис git push <remote> <branch>:
git push origin serverfix (отправляепмп на сервер, зарегиестрированный локально ранее как origin 
                           нашу локальную ветку serverfix ) 
----------------
Аналогично можно выполнить 
git push origin serverfix:serverfix (произойдёт то же самое, т.е. «возьми мою ветку serverfix 
                                     и сделай её удалённой веткой serverfix».)

 =============== Удаление веток на удалённом сервере ==============================
git push origin --delete serverfix (удалям дальнюю ветку serverfix если уже промерджили ее в ветку master)
видим на экране
To https://github.com/schacon/simplegit
- [deleted] serverfix
Всё, что делает эта строка — удаляет указатель на сервере. Как правило, Git сервер хранит
данные пока не запустится сборщик мусора, поэтому если ветка была удалена случайно,чаще всего её легко восстановить.
==================================================================================
====================== Перебазирование =========================================== 
==================================================================================
Внимание! Прежде чем пользоваться этой методолгие в групповой разработке на дальнем репозитории
          важно чтобы все договорилсиь заранее так, чтобы все вместо простой команды "git pull"
          испосльзовали ее усложненную версию с ключем ребазирования "git pull --rebase"
В Git есть два способа внести изменения из одной ветки в другую: слияние и
перебазирование. Перебазирование повторяет изменения из одной ветки поверх другой в том порядке, в
котором эти изменения были сделаны, в то время как слияние берет две конечные точки и
сливает их вместе.

$ git checkout experiment (переключаемся на нашу временную ветку в которой мы сделали изменения 
                           чтобы потмо накатить их на master)
$ git rebase master       (весь перечень коммитов сделаных в ветке experiment накатываем 
                           на последний комит master. При этом мы пересоздаем последний коммит
                           в ветке experiment , но такой, который учел все комиты master)             
$ git checkout master    (перключаемся на мастер, чтобы накатить на него тот последний комит из предыдущей команды)
$ git merge experiment   (сливаем этот комит из ветки experiment с веткой мастер. 
                          Теперь вертка master имеет все изменения ветки experiment но самих коммитов получилось
                          меньше а история комитов чище. Проще говоря, слияние берет две конечные точки 
                          и сливает их вместе.)

Учтите, что снимок, на который ссылается ваш последний коммит — является ли он
последним коммитом после перебазирования или коммитом слияния после слияния — в
обоих случаях это один и тот же снимок, отличаются только истории коммитов.
Перебазирование повторяет изменения из одной ветки поверх другой в том порядке, в
котором эти изменения были сделаны, в то время как слияние берет две конечные точки и
сливает их вместе.
Ребазирование можно делать с ключем -i (--interacrive) чтобы свести все комиты в один единый комит. 
Например: git rebase -i   (но пока неясно как это работает)

---------------------------------------------------------------------------------------------------
Есть более сложные ребазирования. Например 
git rebase --onto master server client (Переключись на ветку client, найди изменения относительно
                                        ветки server и примени их для ветки master. 
                                        При эом мы еще пока находимся в ветке client а ветка master еще не тронута)
git checkout master                    (переключаемся на ветку мастер чтобы в нее накатить изменения ветки client)
git merge client                       (находясь в ветке master накатываем в нее изменения ветки client)
git branch -d client                   (удалияем ветки client, т.к. все сделанные в ней изменения 
                                        мы уже накатили в ветку master)
---------------------------------------------------------------------------------------------------
Представим, что вы решили добавить наработки и из ветки server. Мы можем выполнить перебазирование ветки 
server относительно ветки master без предварительного переключения на неё при помощи команды 
git rebase <basebranch> <topicbranch>, которая извлечёт тематическую ветку (в данном случае server) 
и применит изменения в ней к базовой ветке (master):
git rebase master server (Повторяем всю работу, сделанную в ветке server поверх ветки master)
git checkout master     (переключаемся на ветку мастер чтобы в нее накатить изменения ветки client)
git merge server        (находясь в ветке master накатываем в нее изменения ветки server)
git branch -d server    (удалияем ветки server, т.к. все сделанные в ней изменения 
                         мы уже накатили в ветку master)
----------------------------------------------------------------------------------------------------
=============================== ВНИМАНИЕ! ОПАСНОСТИ ПЕРЕБАЗИРОВАНИЯ ================================
Но даже перебазирование, при всех своих достоинствах, не лишено недостатков, которые
можно выразить одной строчкой: 
                  Не перемещайте коммиты, уже отправленные в публичный репозиторий !
                  rebase local changes before pushing to clean up your work, 
                  but never rebase anything that you’ve pushed somewhere
Когда мы что-то перемещаем в дальний репозиторий, мы отменяем существующие коммиты и создаёте новые,
похожие на старые, но являющиеся другими. Если мы куда-нибудь отправляем свои
коммиты и другие люди забирают их себе и в дальнейшем основывают на них свою работу,
а затем мы переделываете эти коммиты командой git rebase и выкладываете их снова, то
наши коллеги будут вынуждены заново выполнять слияние для своих наработок. В итоге,
когда вы в очередной раз попытаетесь включить их работу в свою, вы получите путаницу.
--------------------------Меняя базу, меняй основание-------------------------------------------
Во избежание ситуаций, когда другой пользователь сделал rebase в дальней ветке, тем самым
почистив\удалив ненужные ему "мусорные" коммиты, а у нас локально они еще сохранились как обычные
и соответсвенно (когда мы отправим наши изменения на дальний сервер), эти "мусорные" комиты опять 
вернутья, нам надо использовать команду pull вместе с ключем --rebase вместо обычного git pull. Т.е.
                  git pull --rebase     (а не просто git pull)
Вспомним, что команда git pull фактически выполняет 2 команды = git fetch + git merge
Или вручную перезакачать изменения с дального сервера с помощью команд fetch и rebase:
                  git fetch
                  git rebase teamone/master.
-------------------------- ПРИМЕЧАНИЕ ---------------------------
Если вы используете git pull и хотите использовать --rebase по умолчанию, вы можете
установить соответствующее значение конфигурации pull.rebase с помощью команды 
                   git config --global pull.rebase true.
----------------------------------------------------------------


=============================== Working with Remotes ==========================================
Remote repositories are versions of your project that are hosted on the Internet or
network somewhere. You can have several of them, each of which generally is either read-only or
read/write for you. Collaborating with others involves managing these remote repositories and
pushing and pulling data to and from them when you need to share work.
Remote repositories can be on your local machine.The word “remote” does not necessarily imply 
that the repository is somewhere else on the network or Internet, only that it is elsewhere. 
Working with such a remote repository would still involve all the
standard pushing, pulling and fetching operations as with any other remote.
git clone https://github.com/schacon/ticgit   (copy remote repository to lcal dolder = ticgit )
cd ticgit                                     (enter into just created new local folder = ticgit)
git remote    (returns the name of remote repository, like:
                "origin".  ( "origin" is default name for remote rep.)
git remote -v (shows not just the name, but the whole URL-address like :
               origin https://github.com/schacon/ticgit (fetch)
               origin https://github.com/schacon/ticgit (push)
----------------------------------------------------------------------------------------------
We can use clone-command, but also use command =  "git remote add <URL>" 
git remote add PB https://github.com/paulboone/ticgit (add shortcut to remote Repository  with name = PB)
git fetch PB                                          (Download localy remote Repository. After that master branch
                                                       is now accessible locally as PB/master and we can merge it 
                                                       into one of our local branches)   
git fetch origin                                      (update local repository added by clone-commad
                                                      "Origin" is usually defaul name for remote repository we cloned)  
------------------------------------ PULLING UPDATES FROM REMOTE ------------------------------
git pull                                              (A simpler way to automatically fetch and then merge remote branch 
                                                       into your current local branch.)     

------------------------------------ PUSHING UPDATES TO REMOTE ------------------------------
If you want to push your master branch to your origin server (again, cloning generally sets up both of those names 
for you automatically),then you can run this to push any commits you’ve done back up to the server:
git push origin master  (git push <remote> <branch> Send local branch-commits to Remote branch with the same name)
-------------------------------------VIEW REMOTE INFO ----------------------------------------
git remote show origin (see INFO from Remote )
-------------------------------------RENAME REMOTE REP ---------------------------------------
You can run git remote rename to change a remote’s shortname
git remote rename pb paul   (rename remote REP from pb to paul. 
                             What used to be referenced at pb/master is now at paul/master.)   
git remote                  (see that renaming actually happend)
-------------------------------------DELETE LOCAL SHORTCUT REMOTE BRUNCH --------------------- 
git remote remove paul (Once you delete the reference to a remote this way, 
                        all remote-tracking branches and configuration
                        settings associated with that remote are also deleted.
---------------------------------------------------------------------------------------------

========================= Adding REMOTE REPs =========================
git remote add local_proj /srv/git/project.git (add local repositoty as if it were remote. Not recomended)
git clone https://example.com/gitproject.git (if use HHTP protocol)

git clone ssh://[user@]server/project.git (if use ssh-protocol)
   or git clone [user@]server:project.git (In both cases above, if you don’t specify the optional username, 
                                           Git assumes the user you’re currently logged in as.
                                            Note, that SSH is that it doesn’t support anonymous access 
                                            to your Git repository )
===================== создание ключей для SSH (page 112)  ===========================
see https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent
ssh-keygen -o
===========================================================================
               ПРИМЕР простейшей работы c Git в многпользовательском режиме (стр 132)
===========================================================================
That is one of the simplest workflows. You work locally for a while (generally in a topic branch), and
merge that work into your local master branch when it’s ready to be integrated. When you want to share
that work, you fetch and merge your local master from local "shortcut-branch" = origin/master if it has changed, 
and finally push to the master branch on the server. The general sequence is something like this:

1) git clone jessica@githost:simplegit.git  (клонирем дальний репозиторий)
   или
   git clone https://github.com/schacon/ticgit   (copy remote repository to local folder = ticgit )
   При этом у нас создается локальная ветка master (в которой мы находимся если специально не преключаемся на новую
   только что созданную нами ветку) Также создается и "ярлыковая" ветка origin/master которая ссылается на дальний репоз.
2) cd simplegit/ (переходим в локальную папку скопирпованного репозитория)
3) Редактируем + сохранем какой-то файл локально
4) git commit -a -m 'Add reset task' (комитим локально сделанные изменения. По умолчанию мы сейчас в ветке master)
                                      при этом ключ "-a" добавлет измененный файл в сиcт. папку ".git", которую 
                                      называют "стеджевой зоной" или "индексом" для будущего комита
                                      (т.к. комиты могут делаться только из этой зоны)
                                      а ключ "-m" позволяет привязать к этому комиту описание
5) git push origin master   (отсылаем сделанные изменения в дальний репозиторий)
               ПРИМЕЧАНИЕ. Если стоит запрет пушить в дальнюю ветку master, можно пушить
               в другй ветку, в которой будут накапливаться изменения из разных груп
               а затем руководитель проекта промержит эту ветку с веткой мастер. Тогда используем командц ниже:
               git push -u origin featureA   (пушим в дальнюю ветку featureA, а не в ветку master)
               С ключом -u (полный вариант --set-upstream) мы создаём (если ещё не существует) 
               в дальнем репозитории ветку, соответствующую нашей локальной и связываем их, чтобы:
               - В remote/branchname будет производиться push в локальную ветку branchname
               - Из remote/branchname будет производиться pull в локальную ветку branchname
               Кроме того, когда мы пушим локальную ветку в дальнюю, названия веток может не совпадать
               Тогда надо использовать дополнительне возможности команды push. Например
               git push -u origin featureB:featureBee (изменения локальной ветки featureB отправляем 
                                                       в дальнюю ветку featureBee, чье имя немного отличается)  
 6) если после этого кто-то другой сделал теже самые шаги и попробует отправить 
   свои изменения в дальний репозиторий командой: git push origin master
   он получит ошибку потому что файл в дальнем репозитории уже был кем-то изменен
   и нужно с ним сначала "синхронизироватья"  а затем "промерджиться"
  - git fetch origin   (origin - это локальный ярлык на дальнюю ветку origin/master 
                        при этом обнвится и увидит все новые изменения)
  - git merge origin/master (т.е. находясь в локальной ветке master, он накатывает 
                             на нее изменения из локальной ссылки на дальнюю ветку master
                             которая локально имеет неизменяемое имя = "origin/master"
    -----------------------ПРИМЕЧАНИЕ----------------------------------------------
    Вместо двух отдельных команд fetch и merge можно использовать одну = pull, 
    git pull работает как git fetch но при этом делает еще и мердж вашей ветки с дальней веткой
    Выполнение git pull, как правило, извлекает (fetch) данные с сервера, с которого
    мы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над
    которым мы в данный момент работаем
    ------------------------------------------------------------------------------
7) когда локальный мердж выше отработал успешно и протестировал, все измения еще пока хранятся локально
   и необходимо их отправить в дальний пепозиторий, т.е. "пропушить"
git push origin master  (отправляем изменения в дальний репозиторий)
8) Если теперь другой пользователь тоже сделает изменения (например ушел вперед с новой веткой для патча 
  своих изменений = issue54, ему надо сначала префрешить ссылку на дальнюю ветку "origin/master"
  а заетм он может сравнить по логу какие новые изменения сделал первый пользователь
git fetch origin  (прорефрешились из дальним репозитория)
git log --no-merges issue54..origin/master  (находим разницу в комитах между локальными ярлыковой веткой и веткой патча)
        The issue54..origin/master syntax is a log filter that asks Git to display only those commits that are
        on the latter branch (in this case origin/master) that are not on the first branch (in this case issue54).
9) После того как работа в локальной ветке = issue54 закончена , ее надо промержить с онсновной локальной веткой
git checkout master  (переключаемся в основную ветку которая примет изменения)
       ------------------------------------------------------------------------------------------------
       ПРИМЕЧАНИЕ В данном примере у нас уже есть локальная ветка master на которую можно переключиться
       А что если мы хотим создать новую локальную ветку на основе дальней ветки master? 
       Тогда используем ключ =u, который при переключении создаст новую ветку, а также указыаем "ярлыковую" 
       ветку-источник origin/master на основе которой будет создаваться наша локальная ветка featureB 
       git checkout -b featureB origin/master (starts a new feature branch, basing it off the server’s master branch)
       --------------------------------------------------------------------------------------------------
git merge issue54 (мерджим ветку issue54  поверх ветки master)
git merge origin/master (мерджим локальную ветку master  (на которой сечас находимся) 
                         с ярлыковой локальной веткой = origin/master)
10) теперь когда локальная ветка мастер промерджена с веткой патча и с ярлыковой веткой можно
    отправлять эти объединенный изменения в дальний репозиторий, т.е. "пропушить" их
git push origin master

======================= ОПТИМИЗАЦИЯ КОМИТОВ (Использование ключа --squash) ==========================
Иногда все наши изменения (которые могут включать массу "мусорных" комитов
надо преобразовать в один общий объединенный комит. Это похоже на rebase
когда запоминаются все наши изменения из другой вспомогательной ветки, но впоследствие применяются к ветке master
на основе ее последнего загруженного состояния, а не на основе этой другой другой ветки в которой работали до этого)
Т.е. дельта изменений сначала где-то накапливается (во временных фалах) , а потом формирутеся
общий комит опираясь уже не на нашу другую ветку в которой мы делали изменения, а на master-ветке 
с учетом ее текущего состояния. Именно так и делает rebase, но при этом все-таки это еще не один единый комит!
Но можно еще и по другому поступить. Сделать нечто похожее без rebase, а на основе merge, как показано ниже
git checkout master
git merge --squash feature123  (собираем все комиты ветки feature123  в единый общий комит, 
                                причем так что они теперь базируются по ветке master
                                но самого комита в ветку master пока не делаем)
git commit -m 'merged feature #123' (Все изменения в ветке feature123 становятся одним коммитом в ветке master)
------------------------------------- NOTE --------------------------------------------------------
The --squash option takes all the work on the merged branch (feature123) and squashes it into one changeset
producing the repository state as if a real merge happened, without actually making a merge commit.
This means your future commit will have one parent only and allows you to introduce all
the changes from another branch and then make more changes before recording the new commit.
Also the --no-commit option can be useful to delay the merge commit in case of the default merge process.
----------------------------------------------------------------------------------------------------
============== Формирование метаданнх изменений, которые потом можно отслать по почте (стр 148) ==============
You use git format-patch to generate the mbox-formatted files that you can email to the list  — it turns each 
commit into an email message with the first line of the commit message as the subject and the rest of the message 
plus the patch that the commit introduces as the body. 
The nice thing about this is that applying a patch from an email generated with format-patch 
preserves all the commit information properly
                       git format-patch -M origin/master
After that see on screen:
0001-add-limit-to-log-function.patch
0002-increase-log-output-to-30-from-25.patch

The format-patch command prints out the names of the patch files it creates. 
The -M switch tells Git to look for renames. The files end up looking like this:
                      cat 0001-add-limit-to-log-function.patch
The result on screen is
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] Add limit to log function
Limit log functionality to the first 20
..........
..........
ПРИМЕЧАНИЕ: see also https://git-send-email.io/
===================================================================================================
Applying a Patch with apply
===================================================================================================
If you received the patch from someone who generated it with git diff or some variation of the
Unix diff command (which is not recommended; see the next section), you can apply it with the git
apply command. Assuming you saved the patch at /tmp/patch-ruby-client.patch, you can apply the
patch like this:
git apply /tmp/patch-ruby-client.patch
You can also use git apply to see if a patch applies cleanly before you try actually applying it — you
can run git apply --check with the patch
git apply --check 0001-see-if-this-helps-the-gem.patch
If there is no output, then the patch should apply cleanly.
============================= FIND DIFF IN COMMITS =================================================
The command below shows you only the work your current topic branch = contrib has introduced since its
common ancestor with master. That is a very useful syntax to remember.
git diff master...contrib